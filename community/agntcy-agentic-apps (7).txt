Directory structure:
└── 02-weather-vibes-agent/
    ├── README.md
    ├── 00-overview.md
    ├── 01-project-setup.md
    ├── 02-creating-acp-descriptor.md
    ├── 03-creating-the-tools.md
    ├── 04-create-the-agent.md
    ├── 05-system-prompt-template.md
    ├── 06-implementing-the-server.md
    └── weather_vibes/
        ├── descriptor.py
        ├── requirements.txt
        ├── agent/
        │   ├── __init__.py
        │   ├── descriptor.py
        │   └── weather_vibes_agent.py
        ├── templates/
        │   └── system.j2
        └── tools/
            ├── __init__.py
            ├── recommendation_tool.py
            ├── weather_tool.py
            └── youtube_tool.py

================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/README.md
================================================
# Weather Vibes Agent

A practical implementation of the Agent Connect Protocol (ACP) using the Simple Agent Framework. This agent provides weather information, recommends items to bring, and suggests YouTube videos that match the weather vibe.

## Features

- **Weather Information**: Get current weather conditions for any location using OpenWeatherMap
- **Smart Recommendations**: Receive personalized items to bring based on weather conditions
- **Weather-Matched Media**: Discover YouTube videos that match the current weather "vibe"
- **ACP Compliance**: Full implementation of the Agent Connect Protocol for standardized communication
- **State Management**: Maintains search history and favorite locations across sessions

## Architecture

The Weather Vibes agent is built using a modular architecture:

```
┌───────────────────┐     
│  WEATHER VIBES    │     
│  AGENT            │     
│                   │     
│  ┌─────────────┐  │     
│  │ Simple Agent │  │     
│  │ Framework    │  │     
│  └─────────────┘  │     
│        │          │     
│  ┌─────────────┐  │     
│  │ Weather,    │  │     
│  │ Recommend,  │  │     
│  │ YouTube     │  │     
│  │ Tools       │  │     
│  └─────────────┘  │     
│        │          │     
│  ┌─────────────┐  │     
│  │ ACP         │  │     
│  │ Endpoints   │  │     
│  └─────────────┘  │     
│                   │     
└───────────────────┘     
```

### Key Components

1. **Agent Implementation**: `WeatherVibesAgent` class integrating the Simple Agent Framework
2. **ACP Descriptor**: Defines capabilities, input/output schemas, and configuration options
3. **Specialized Tools**:
   - `WeatherTool`: Fetches weather information using OpenWeatherMap
   - `RecommendationsTool`: Suggests items based on weather conditions
   - `YouTubeTool`: Finds videos matching the weather mood
4. **FastAPI Server**: Implements ACP endpoints for agent discovery and execution
5. **Template System**: Dynamic system prompt generation with Jinja2

## Prerequisites

- Python 3.12+
- OpenAI API key
- OpenWeatherMap API key ([get one here](https://openweathermap.org/api))
- YouTube Data API key ([get one here](https://console.cloud.google.com/apis/library/youtube.googleapis.com))

## Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/agntcy/agentic-apps.git
   cd agentic-apps/tutorials/02-weather-vibes-agent/weather_vibes
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

3. Create a `.env` file with your API keys:
   ```
   OPENAI_API_KEY=your_openai_api_key
   OPENWEATHERMAP_API_KEY=your_openweathermap_key
   YOUTUBE_API_KEY=your_youtube_api_key
   SERVER_PORT=8000
   SERVER_HOST=0.0.0.0
   ```

## Running the Server

Start the ACP-compliant server:

```bash
python main.py
```

The server will start on `http://localhost:8000` by default.

## API Usage

This agent implements the Agent Connect Protocol (ACP). You can interact with it using the following endpoints:

### Agent Discovery

Retrieve a list of available agents:

```bash
curl -X POST http://localhost:8000/agents/search -H "Content-Type: application/json" -d '{}'
```

Expected response:
```json
{
  "agents": [
    {
      "id": "weather_vibes",
      "metadata": {
        "ref": {
          "name": "org.example.weathervibes",
          "version": "0.1.0"
        },
        "description": "An agent that provides weather information, item recommendations, and matching YouTube videos."
      }
    }
  ]
}
```

### Get Agent Descriptor

Retrieve the full ACP descriptor for the Weather Vibes agent:

```bash
curl -X GET http://localhost:8000/agents/weather_vibes/descriptor
```

### Start a Run

Execute the agent with specific input:

```bash
curl -X POST http://localhost:8000/runs -H "Content-Type: application/json" -d '{
  "agent_id": "weather_vibes",
  "input": {
    "location": "San Francisco",
    "units": "metric"
  },
  "config": {
    "verbose": true,
    "max_recommendations": 5
  }
}'
```

This will return a run ID:
```json
{
  "id": "run_uuid",
  "agent_id": "weather_vibes",
  "status": "pending"
}
```

### Check Run Status

Check the status of a run:

```bash
curl -X GET http://localhost:8000/runs/run_uuid
```

### Get Run Results

Wait for and retrieve run results:

```bash
curl -X GET http://localhost:8000/runs/run_uuid/wait
```

Example response:
```json
{
  "type": "result",
  "result": {
    "weather": {
      "location": "San Francisco",
      "temperature": 15.2,
      "condition": "Cloudy",
      "humidity": 75,
      "wind_speed": 12.3
    },
    "recommendations": [
      "Light jacket",
      "Umbrella",
      "Water bottle",
      "Sunglasses",
      "Scarf"
    ],
    "video": {
      "title": "Cloudy Day Chill Music Mix 2023",
      "url": "https://www.youtube.com/watch?v=example",
      "thumbnail": "https://i.ytimg.com/vi/example/hqdefault.jpg"
    }
  }
}
```

## Example Client

You can use the included client script to test the agent:

```bash
python client_example.py "New York" --units metric --verbose
```

## ACP Implementation Details

This agent demonstrates several key ACP concepts:

### 1. Agent ACP Descriptor

The agent exposes a descriptor with:
- **Metadata**: Name, version, and description
- **Capabilities**: Support for threads and streaming
- **Input/Output Schemas**: JSON schemas for standardized I/O
- **Configuration**: Optional parameters to customize behavior

### 2. Run Management

Handles run lifecycle including:
- Creating runs with unique identifiers
- Tracking run status (pending, success, error)
- Processing inputs according to schemas
- Standardized error handling

### 3. Thread State Handling

Maintains conversational state across requests:
- Preserves search history
- Supports favorite locations
- Updates state based on user interactions

### 4. Tools Integration

Demonstrates how to integrate external APIs:
- Weather data from OpenWeatherMap
- Video search from YouTube
- Recommendation logic based on conditions

## Extending the Agent

You can extend the Weather Vibes agent by:

1. Adding new tools in the `tools/` directory
2. Enhancing the descriptor with new capabilities
3. Modifying the system prompt in `templates/system.j2`
4. Adding additional ACP features like streaming responses

## Troubleshooting

If you encounter issues:

- **API Key Errors**: Verify your API keys in the `.env` file
- **Connection Issues**: Check network connectivity to external APIs
- **Run Processing Errors**: Check the server logs for detailed error messages

## License

This project is licensed under the Apache 2.0 License - see the [LICENSE](LICENSE) file for details.





================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/00-overview.md
================================================
# Building a Weather Vibes Agent using the Agent Context Protocol

Now that you've learned the basics of the Agent Context Protocol, let's build an agent together to help you not only get the weather, but also the vibe of the weather in your area. 

## Overview
Our Weather Vibes agent will:
- Get the current weather for a user-specified location
- Recommend items to bring based on the weather conditions (umbrella, sunglasses, etc.)
- Suggest a YouTube video that matches the weather "vibe"

This will demonstrate several key ACP concepts:
Agent descriptors and capabilities
Run management
Tool integration
Structured inputs and outputs
Let's build this step by step!

Follow along with this tutorial to build your own Weather Vibes agent.


### Step 1: Project Setup

```
mkdir -p weather_vibes/agent weather_vibes/tools weather_vibes/templates
cd weather_vibes
touch __init__.py
touch requirements.txt
touch main.py
touch .env.example
touch README.md
```


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/01-project-setup.md
================================================
# Weather Vibes Agent Project Setup

Lets now create the project structure for our Weather Vibes agent, and add the necessary files.

## Project Setup

From within your project directory, run the following commands to create the necessary files:

```
mkdir -p weather_vibes/agent weather_vibes/tools weather_vibes/templates
cd weather_vibes
touch __init__.py
touch requirements.txt
touch main.py
touch .env.example
touch README.md
```

Now, lets create a `requirements.txt` file to install the necessary dependencies:

```
# ACP and Simple Agent Framework
git+https://github.com/rungalileo/simple-agent-framework.git
fastapi==0.110.0
uvicorn==0.27.0
python-dotenv==1.0.0

# Weather & YouTube APIs
requests==2.31.0
pyowm==3.3.0  # OpenWeatherMap client
google-api-python-client==2.111.0  # YouTube API
```

And then, an `.env` file to store our API keys:

```
# API Keys
OPENAI_API_KEY=your_openai_api_key_here
OPENWEATHERMAP_API_KEY=your_openweathermap_api_key_here
YOUTUBE_API_KEY=your_youtube_api_key_here

# Server Configuration
SERVER_PORT=8000
SERVER_HOST=0.0.0.0
```

Once you've added the above files, you can add the following to your `.gitignore` file to avoid committing the `.env` file to the repository:

```
.env
```

When complete, your project directory should look like this:

```
weather_vibes/
├── agent/
├── tools/
├── templates/
├── __init__.py
├── main.py

Now, lets move to step two where we're creating the ACP Agent Descriptor and Capabilies. 


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/02-creating-acp-descriptor.md
================================================
## Creating the ACP Agent Descriptor and Capabilities

Now that we have our project setup, lets create the ACP Agent Descriptor and Capabilities.

### Step 1: Create the Agent Descriptor

A key part of implementing ACP is defining an Agent ACP Descriptor. This tells clients what your agent can do and how to interact with it.

Let's create a file called weather_vibes/agent/descriptor.py:

(psst, don't want to scroll too much? find a link to this file in the [project repo](https://github.com/agntcy/agentic-apps/blob/main/tutorials/02-weather-vibes-agent/descriptor.py))

```
"""
Agent ACP Descriptor for the Weather Vibes agent.
This defines the agent's capabilities, inputs, outputs, and configuration.
"""

WEATHER_VIBES_DESCRIPTOR = {
    "metadata": {
        "ref": {
            "name": "org.example.weathervibes",
            "version": "0.1.0",
            "url": "https://github.com/agntcy/agentic-apps/weather_vibes"
        },
        "description": "An agent that provides weather information, item recommendations, and matching YouTube videos."
    },
    "specs": {
        "capabilities": {
            "threads": True,
            "interrupts": False,
            "callbacks": False,
            "streaming": True
        },
        "input": {
            "type": "object",
            "description": "Input for the Weather Vibes agent",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The location to get weather for (city name, zip code, etc.)"
                },
                "units": {
                    "type": "string",
                    "enum": ["metric", "imperial"],
                    "default": "metric",
                    "description": "Unit system for temperature and measurements"
                }
            },
            "required": ["location"]
        },
        "output": {
            "type": "object",
            "description": "Weather Vibes agent output",
            "properties": {
                "weather": {
                    "type": "object",
                    "description": "Current weather information",
                    "properties": {
                        "location": {"type": "string"},
                        "temperature": {"type": "number"},
                        "condition": {"type": "string"},
                        "humidity": {"type": "number"},
                        "wind_speed": {"type": "number"}
                    }
                },
                "recommendations": {
                    "type": "array",
                    "description": "Items recommended to bring based on the weather",
                    "items": {"type": "string"}
                },
                "video": {
                    "type": "object",
                    "description": "A YouTube video matching the weather vibe",
                    "properties": {
                        "title": {"type": "string"},
                        "url": {"type": "string"},
                        "thumbnail": {"type": "string"}
                    }
                }
            }
        },
        "config": {
            "type": "object",
            "description": "Configuration for the Weather Vibes agent",
            "properties": {
                "verbose": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether to include detailed weather information"
                },
                "max_recommendations": {
                    "type": "integer",
                    "default": 5,
                    "description": "Maximum number of recommendations to provide"
                },
                "video_mood": {
                    "type": "string",
                    "description": "Optional mood override for video selection"
                }
            }
        },
        "thread_state": {
            "type": "object",
            "description": "Thread state for the Weather Vibes agent",
            "properties": {
                "search_history": {
                    "type": "array",
                    "description": "History of previously searched locations",
                    "items": {"type": "string"}
                },
                "favorite_locations": {
                    "type": "array",
                    "description": "User's favorite locations",
                    "items": {"type": "string"}
                }
            }
        }
    }
}
```

This descriptor defines:
- **Metadata**: Basic information about our agent
- **Capabilities**: Which ACP features we support (threads, streaming)
- **Input Schema**: What users need to provide (location and optional units)
- **Output Schema**: What our agent will return (weather, recommendations, video)
- **Config Schema**: Optional configuration parameters
- **Thread State**: What information we maintain across conversations

When complete, move on to the next step where we'll create the tools our agent will use.


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/03-creating-the-tools.md
================================================
# Step 3: Creating the Tools

Now, let's implement the tools our agent needs. 

(As before, don't want to scroll too much? find a link to all of the tools in the [project repo](https://github.com/agntcy/agentic-apps/blob/main/tutorials/02-weather-vibes-agent/tools))

First, create weather_vibes/tools/weather_tool.py:

```
"""
Weather tool for fetching current weather conditions using OpenWeatherMap API.
"""
import os
from typing import Dict, Any, Optional
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool
import requests

class WeatherInput(BaseModel):
    """Input schema for the weather tool"""
    location: str
    units: str = "metric"

class WeatherTool(BaseTool):
    """Tool for fetching weather information"""
    name = "get_weather"
    description = "Get the current weather conditions for a location"
    tags = ["weather", "utility"]
    input_schema = WeatherInput.model_json_schema()
    
    def __init__(self):
        self.api_key = os.getenv("OPENWEATHERMAP_API_KEY")
        if not self.api_key:
            raise ValueError("OpenWeatherMap API key not found in environment")
        self.base_url = "http://api.openweathermap.org/data/2.5/weather"
    
    async def execute(self, location: str, units: str = "metric") -> Dict[str, Any]:
        """
        Execute the tool to get current weather.
        
        Args:
            location: The location to get weather for (city name, zip code, etc.)
            units: Unit system for temperature (metric or imperial)
            
        Returns:
            Dictionary containing weather information
        """
        params = {
            "q": location,
            "units": units,
            "appid": self.api_key
        }
        
        try:
            response = requests.get(self.base_url, params=params)
            response.raise_for_status()
            data = response.json()
            
            # Extract relevant weather information
            weather_info = {
                "location": data["name"],
                "temperature": data["main"]["temp"],
                "condition": data["weather"][0]["main"],
                "description": data["weather"][0]["description"],
                "humidity": data["main"]["humidity"],
                "wind_speed": data["wind"]["speed"],
                "icon": data["weather"][0]["icon"],
                "feels_like": data["main"]["feels_like"]
            }
            
            return weather_info
        except Exception as e:
            return {
                "error": str(e),
                "message": f"Failed to get weather for location: {location}"
            }
```


This tool uses the OpenWeatherMap API to fetch weather information for a given location.

Next, create a recommendation tool in weather_vibes/tools/recommendation_tool.py:

```
"""
Tool for generating item recommendations based on weather conditions.
"""
from typing import Dict, Any, List
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool

class RecommendationsInput(BaseModel):
    """Input schema for recommendations tool"""
    weather: Dict[str, Any]
    max_items: int = 5

class RecommendationsTool(BaseTool):
    """Tool for generating weather-based recommendations"""
    name = "get_recommendations"
    description = "Get recommendations for items to bring based on weather conditions"
    tags = ["weather", "recommendations"]
    input_schema = RecommendationsInput.model_json_schema()
    
    async def execute(self, weather: Dict[str, Any], max_items: int = 5) -> List[str]:
        """
        Execute the tool to get recommendations.
        
        Args:
            weather: Weather information dictionary
            max_items: Maximum number of recommendations to provide
            
        Returns:
            List of recommended items
        """
        recommendations = []
        
        # Basic recommendation logic based on weather conditions
        condition = weather.get("condition", "").lower()
        temp = weather.get("temperature", 0)
        description = weather.get("description", "").lower()
        
        # Rain-related recommendations
        if any(x in condition.lower() or x in description.lower() for x in ["rain", "drizzle", "shower"]):
            recommendations.extend(["☔", "🧥" ])
        
        # Sun-related recommendations
        if any(x in condition.lower() or x in description.lower() for x in ["clear", "sun"]):
            recommendations.extend(["🕶️", "🧴", "🧢"])
        
        # Temperature-based recommendations
        if temp < 5:  # Cold
            recommendations.extend(["🎿", "🧤", "🧣", "🥶"])
        elif temp < 15:  # Cool
            recommendations.extend(["👖", "🧦", "🌫️"])
        elif temp < 25:  # Warm
            recommendations.extend(["👕", "🩳", "☀️"])
        else:  # Hot
            recommendations.extend(["🥵", "👙", "🌴", "🩴"])
        
        # Wind-related recommendations
        if weather.get("wind_speed", 0) > 20:
            recommendations.append("🌬️", "🪁")
        
        # Return unique recommendations, limited to max_items
        unique_recommendations = list(set(recommendations))
        return unique_recommendations[:max_items]
```

This tool generates recommendations based on weather conditions.

Next, create weather_vibes/tools/youtube_tool.py:


```
"""
Tool for finding YouTube videos that match the weather vibe.
"""
import os
from typing import Dict, Any, Optional
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool
from googleapiclient.discovery import build

class YouTubeInput(BaseModel):
    """Input schema for YouTube tool"""
    weather_condition: str
    mood_override: Optional[str] = None

class YouTubeTool(BaseTool):
    """Tool for finding YouTube videos based on weather conditions"""
    name = "find_weather_video"
    description = "Find a YouTube video that matches the weather vibe"
    tags = ["youtube", "entertainment"]
    input_schema = YouTubeInput.model_json_schema()
    
    def __init__(self):
        self.api_key = os.getenv("YOUTUBE_API_KEY")
        if not self.api_key:
            raise ValueError("YouTube API key not found in environment")
        self.youtube = build('youtube', 'v3', developerKey=self.api_key)
    
    async def execute(self, weather_condition: str, mood_override: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute the tool to find a weather-matching YouTube video.
        
        Args:
            weather_condition: Current weather condition
            mood_override: Optional mood to override search query
            
        Returns:
            Dictionary containing video information
        """
        try:
            # Generate search query based on weather condition and optional mood
            if mood_override:
                query = f"{weather_condition} {mood_override} music"
            else:
                # Map weather conditions to vibes
                vibe_mapping = {
                    "clear": "sunny day vibes music",
                    "sun": "sunny afternoon music",
                    "clouds": "cloudy day chill music",
                    "rain": "rainy day lofi music",
                    "drizzle": "light rain ambience",
                    "thunderstorm": "thunderstorm cozy music",
                    "snow": "snowy day peaceful music",
                    "mist": "foggy morning ambient music",
                    "fog": "foggy atmosphere music"
                }
                
                # Find the closest matching vibe
                for condition_key, vibe_phrase in vibe_mapping.items():
                    if condition_key in weather_condition.lower():
                        query = vibe_phrase
                        break
                else:
                    query = f"{weather_condition} music vibes"
            
            # Execute search
            search_response = self.youtube.search().list(
                q=query,
                part="snippet",
                maxResults=1,
                type="video"
            ).execute()
            
            # Extract video information
            if search_response.get("items"):
                video = search_response["items"][0]
                video_id = video["id"]["videoId"]
                
                return {
                    "title": video["snippet"]["title"],
                    "url": f"https://www.youtube.com/watch?v={video_id}",
                    "thumbnail": video["snippet"]["thumbnails"]["high"]["url"],
                    "channel": video["snippet"]["channelTitle"],
                    "query": query
                }
            else:
                return {"error": "No videos found", "query": query}
        
        except Exception as e:
            return {
                "error": str(e),
                "message": "Failed to find a matching YouTube video"
            }
```

This tool uses the YouTube API to find a video that matches the weather condition and mood.

Finally, create an __init__.py file in the weather_vibes/tools directory:

```
from .weather_tool import WeatherTool
from .recommendations_tool import RecommendationsTool
from .youtube_tool import YouTubeTool

```

When complete, move on to the next step where we'll create the agent.




================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/04-create-the-agent.md
================================================
# Implementing the Agent

Now, let's create the main agent that will use these tools. 

Create weather_vibes/agent/weather_vibes_agent.py:

```
"""
Weather Vibes Agent implementation using the Simple Agent Framework.
"""
import os
import json
from pathlib import Path
from typing import Dict, Any, List, Optional
from jinja2 import Environment, FileSystemLoader

from agent_framework.agent import Agent
from agent_framework.state import AgentState
from agent_framework.utils.llm import OpenAIChat
from agent_framework.utils.logging import AgentLogger

from ..tools import WeatherTool, RecommendationsTool, YouTubeTool
from .descriptor import WEATHER_VIBES_DESCRIPTOR

class WeatherVibesAgent(Agent):
    """
    Agent that provides weather information, recommendations, and matching videos.
    Implements the Agent Connect Protocol (ACP) for standardized communication.
    """
    
    def __init__(self, agent_id: str = "weather_vibes"):
        super().__init__(agent_id=agent_id)
        
        # Initialize state
        self.state = AgentState()
        self.state.set("search_history", [])
        self.state.set("favorite_locations", [])
        
        # Set up template environment
        template_dir = Path(__file__).parent.parent / "templates"
        self.template_env = Environment(
            loader=FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Set up LLM
        self.llm = OpenAIChat(
            api_key=os.getenv("OPENAI_API_KEY"),
            model="gpt-4"
        )
        
        # Set up logger
        self.logger = AgentLogger(agent_id=self.agent_id)
        
        # Register tools
        self._register_tools()
        
        # Store descriptor
        self.descriptor = WEATHER_VIBES_DESCRIPTOR
        
    def _register_tools(self) -> None:
        """Register agent-specific tools"""
        self.tool_registry.register(
            metadata=WeatherTool.get_metadata(),
            implementation=WeatherTool()
        )
        
        self.tool_registry.register(
            metadata=RecommendationsTool.get_metadata(),
            implementation=RecommendationsTool()
        )
        
        self.tool_registry.register(
            metadata=YouTubeTool.get_metadata(),
            implementation=YouTubeTool()
        )
    
    async def _generate_system_prompt(self) -> str:
        """Generate the system prompt using the template"""
        template = self.template_env.get_template("system.j2")
        return template.render(
            search_history=self.state.get("search_history"),
            favorite_locations=self.state.get("favorite_locations")
        )
    
    async def get_acp_descriptor(self) -> Dict[str, Any]:
        """
        Return the ACP descriptor for this agent.
        This implements the ACP agent discovery capability.
        """
        return self.descriptor
    
    async def process_acp_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process an ACP request and generate a response.
        This implements the ACP run execution capability.
        
        Args:
            request: The ACP request payload
            
        Returns:
            An ACP response payload
        """
        await self.logger.on_agent_start(request)
        
        try:
            # Extract relevant information from the request
            input_data = request.get("input", {})
            config = request.get("config", {})
            metadata = request.get("metadata", {})
            
            # Parse input and config
            location = input_data.get("location")
            units = input_data.get("units", "metric")
            verbose = config.get("verbose", False)
            max_recommendations = config.get("max_recommendations", 5)
            video_mood = config.get("video_mood")
            
            # Validate input
            if not location:
                return {
                    "error": 400,
                    "message": "Invalid input: 'location' field is required"
                }
            
            # Update search history
            search_history = self.state.get("search_history", [])
            if location not in search_history:
                search_history.append(location)
                self.state.set("search_history", search_history[-5:])  # Keep last 5
            
            # Step 1: Get weather information
            weather_tool = self.tool_registry.get_tool("get_weather")
            weather_result = await weather_tool.execute(location=location, units=units)
            
            if "error" in weather_result:
                return {
                    "error": 500,
                    "message": f"Weather API error: {weather_result['message']}"
                }
            
            # Step 2: Get recommendations
            recommendations_tool = self.tool_registry.get_tool("get_recommendations")
            recommendations = await recommendations_tool.execute(
                weather=weather_result,
                max_items=max_recommendations
            )
            
            # Step 3: Get matching YouTube video
            youtube_tool = self.tool_registry.get_tool("find_weather_video")
            video_result = await youtube_tool.execute(
                weather_condition=weather_result["condition"],
                mood_override=video_mood
            )
            
            # Prepare the response
            result = {
                "weather": weather_result,
                "recommendations": recommendations,
                "video": video_result
            }
            
            # If not verbose, filter out some weather details
            if not verbose and "weather" in result:
                result["weather"] = {
                    "location": weather_result["location"],
                    "temperature": weather_result["temperature"],
                    "condition": weather_result["condition"],
                    "humidity": weather_result["humidity"],
                    "wind_speed": weather_result["wind_speed"]
                }
            
            # Format response according to ACP standards
            response = {
                "output": result
            }
            
            # Add the original agent_id to the response
            if "agent_id" in request:
                response["agent_id"] = request["agent_id"]
                
            # Add metadata if present in the request
            if metadata:
                response["metadata"] = metadata
                
            await self.logger.on_agent_end(response)
            return response
            
        except Exception as e:
            await self.logger.on_tool_error("process_request", e)
            return {
                "error": 500,
                "message": f"Error processing request: {str(e)}"
            }
```

This agent uses the Simple Agent Framework to process ACP requests and generate responses.

When complete, move on to the next step where we'll create the main application.





================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/05-system-prompt-template.md
================================================
# Creating the System Prompt Template

Create weather_vibes/templates/system.j2 (also available in weather_vibes sample folder):

```
You are the Weather Vibes assistant, an agent that helps users get weather information, item recommendations, and matching music.

Your capabilities:
1. Get current weather for any location
2. Recommend items to bring based on weather conditions
3. Find YouTube videos that match the weather "vibe"

Search history:
{% if search_history %}
Recent locations:
{% for location in search_history %}
- {{ location }}
{% endfor %}
{% else %}
No recent searches.
{% endif %}

{% if favorite_locations %}
Favorite locations:
{% for location in favorite_locations %}
- {{ location }}
{% endfor %}
{% endif %}

When providing recommendations, consider:
- Temperature (cold, cool, warm, hot)
- Precipitation (rain, snow, etc.)
- Wind conditions
- Time of day

Be friendly, helpful, and practical in your recommendations.
```

This template uses Jinja2 templating to dynamically insert the search history and favorite locations into the system prompt.

When complete, move on to the next step where we'll create the main application.




================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/06-implementing-the-server.md
================================================
#  Implementing the Server 

Now, let's create the main server application in weather_vibes/main.py:

```
"""
Weather Vibes ACP Server
Implements the Agent Connect Protocol (ACP) to serve the Weather Vibes agent.
"""
import os
import json
import logging
import asyncio
from typing import Dict, Any
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse

from agent.weather_vibes_agent import WeatherVibesAgent

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("weather_vibes_server")

# Initialize FastAPI app
app = FastAPI(title="Weather Vibes ACP Server")

# Initialize Weather Vibes Agent
weather_vibes_agent = WeatherVibesAgent(agent_id="weather_vibes")

# ACP API Endpoints

@app.get("/")
async def root():
    """Root endpoint with server information"""
    return {
        "name": "Weather Vibes ACP Server",
        "version": "0.1.0",
        "description": "Agent Connect Protocol implementation for Weather Vibes"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "ok", "agent": weather_vibes_agent.agent_id}

@app.post("/agents/search")
async def search_agents(request: Dict[str, Any]):
    """
    ACP agent search endpoint.
    Returns a list of agents matching the search criteria.
    """
    # For this simple example, we'll always return our single agent
    return {
        "agents": [
            {
                "id": weather_vibes_agent.agent_id,
                "metadata": weather_vibes_agent.descriptor["metadata"]
            }
        ]
    }

@app.get("/agents/{agent_id}/descriptor")
async def get_agent_descriptor(agent_id: str):
    """
    ACP agent descriptor endpoint.
    Returns the full ACP descriptor for the specified agent.
    """
    if agent_id != weather_vibes_agent.agent_id:
        raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")
        
    return await weather_vibes_agent.get_acp_descriptor()

@app.post("/runs")
async def create_run(request: Request):
    """
    ACP run creation endpoint.
    Starts a new run for the specified agent with the given input and config.
    """
    # Parse request payload
    payload = await request.json()
    agent_id = payload.get("agent_id")
    
    if agent_id != weather_vibes_agent.agent_id:
        raise HTTPException(status_code=404, detail=f"Agent '{agent_id}' not found")
    
    # For a simple implementation, we'll process the request immediately
    # In a production environment, you would queue the run and process it asynchronously
    
    # Create a run ID
    import uuid
    run_id = str(uuid.uuid4())
    
    # Store request in a simple in-memory store
    # In production, use a proper database
    app.state.runs = getattr(app.state, "runs", {})
    app.state.runs[run_id] = {
        "id": run_id,
        "agent_id": agent_id,
        "status": "pending",
        "request": payload,
        "response": None
    }
    
    # Process the request asynchronously
    asyncio.create_task(process_run(run_id, payload))
    
    # Return the run information
    return {
        "id": run_id,
        "agent_id": agent_id,
        "status": "pending"
    }

@app.get("/runs/{run_id}")
async def get_run(run_id: str):
    """
    ACP run status endpoint.
    Returns the current status of the specified run.
    """
    runs = getattr(app.state, "runs", {})
    
    if run_id not in runs:
        raise HTTPException(status_code=404, detail=f"Run '{run_id}' not found")
        
    return {
        "id": run_id,
        "agent_id": runs[run_id]["agent_id"],
        "status": runs[run_id]["status"]
    }

@app.get("/runs/{run_id}/wait")
async def wait_for_run(run_id: str):
    """
    ACP run wait endpoint.
    Waits for the run to complete and returns the result.
    """
    runs = getattr(app.state, "runs", {})
    
    if run_id not in runs:
        raise HTTPException(status_code=404, detail=f"Run '{run_id}' not found")
    
    # Wait for the run to complete (with timeout)
    max_attempts = 30
    for _ in range(max_attempts):
        if runs[run_id]["status"] != "pending":
            break
        await asyncio.sleep(1)
    
    # Check if run completed
    if runs[run_id]["status"] == "pending":
        raise HTTPException(status_code=408, detail="Request timeout")
    
    # Return the result
    if runs[run_id]["status"] == "success":
        return {
            "type": "result",
            "result": runs[run_id]["response"]["output"]
        }
    else:
        return {
            "type": "error",
            "error": runs[run_id]["response"].get("error", 500),
            "message": runs[run_id]["response"].get("message", "Unknown error")
        }

async def process_run(run_id: str, payload: Dict[str, Any]):
    """
    Process a run asynchronously.
    Updates the run status and stores the response.
    """
    runs = getattr(app.state, "runs", {})
    
    try:
        # Process the request
        response = await weather_vibes_agent.process_acp_request(payload)
        
        # Update run status and store response
        if "error" in response:
            runs[run_id]["status"] = "error"
        else:
            runs[run_id]["status"] = "success"
            
        runs[run_id]["response"] = response
        
    except Exception as e:
        logger.error(f"Error processing run {run_id}: {e}")
        runs[run_id]["status"] = "error"
        runs[run_id]["response"] = {
            "error": 500,
            "message": f"Internal server error: {str(e)}"
        }

if __name__ == "__main__":
    import uvicorn
    
    host = os.getenv("SERVER_HOST", "0.0.0.0")
    port = int(os.getenv("SERVER_PORT", "8000"))
    
    # Run the server
    uvicorn.run("main:app", host=host, port=port, reload=True)
```

This server implements the ACP protocol and provides endpoints for agent search, run creation, status checking, and result retrieval.








================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/descriptor.py
================================================
"""
Agent ACP Descriptor for the Weather Vibes agent.
This defines the agent's capabilities, inputs, outputs, and configuration.
"""

WEATHER_VIBES_DESCRIPTOR = {
    "metadata": {
        "ref": {
            "name": "org.example.weathervibes",
            "version": "0.1.0",
            "url": "https://github.com/agntcy/agentic-apps/weather_vibes"
        },
        "description": "An agent that provides weather information, item recommendations, and matching YouTube videos."
    },
    "specs": {
        "capabilities": {
            "threads": True,
            "interrupts": False,
            "callbacks": False,
            "streaming": True
        },
        "input": {
            "type": "object",
            "description": "Input for the Weather Vibes agent",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The location to get weather for (city name, zip code, etc.)"
                },
                "units": {
                    "type": "string",
                    "enum": ["metric", "imperial"],
                    "default": "metric",
                    "description": "Unit system for temperature and measurements"
                }
            },
            "required": ["location"]
        },
        "output": {
            "type": "object",
            "description": "Weather Vibes agent output",
            "properties": {
                "weather": {
                    "type": "object",
                    "description": "Current weather information",
                    "properties": {
                        "location": {"type": "string"},
                        "temperature": {"type": "number"},
                        "condition": {"type": "string"},
                        "humidity": {"type": "number"},
                        "wind_speed": {"type": "number"}
                    }
                },
                "recommendations": {
                    "type": "array",
                    "description": "Items recommended to bring based on the weather",
                    "items": {"type": "string"}
                },
                "video": {
                    "type": "object",
                    "description": "A YouTube video matching the weather vibe",
                    "properties": {
                        "title": {"type": "string"},
                        "url": {"type": "string"},
                        "thumbnail": {"type": "string"}
                    }
                }
            }
        },
        "config": {
            "type": "object",
            "description": "Configuration for the Weather Vibes agent",
            "properties": {
                "verbose": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether to include detailed weather information"
                },
                "max_recommendations": {
                    "type": "integer",
                    "default": 5,
                    "description": "Maximum number of recommendations to provide"
                },
                "video_mood": {
                    "type": "string",
                    "description": "Optional mood override for video selection"
                }
            }
        },
        "thread_state": {
            "type": "object",
            "description": "Thread state for the Weather Vibes agent",
            "properties": {
                "search_history": {
                    "type": "array",
                    "description": "History of previously searched locations",
                    "items": {"type": "string"}
                },
                "favorite_locations": {
                    "type": "array",
                    "description": "User's favorite locations",
                    "items": {"type": "string"}
                }
            }
        }
    }
}


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/requirements.txt
================================================
# Core dependencies
fastapi==0.110.0
uvicorn==0.27.0
python-dotenv==1.0.0
jinja2==3.1.2
pydantic==2.5.3
rich>=13.0.0

# Direct OpenAI dependency instead of relying on Simple Agent Framework's LLM utility
openai>=1.0.0

# API integrations
requests==2.31.0
google-api-python-client==2.111.0

# Simple Agent Framework
# Comment out if causing issues and use direct OpenAI client instead
git+https://github.com/rungalileo/simple-agent-framework.git@main 


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/agent/__init__.py
================================================
"""
Agent module initialization
"""
# Make the descriptor easily importable
try:
    from .descriptor import WEATHER_VIBES_DESCRIPTOR
except ImportError:
    pass  # Handle the case if the file doesn't exist yet 


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/agent/descriptor.py
================================================
"""
Agent ACP Descriptor for the Weather Vibes agent.
This defines the agent's capabilities, inputs, outputs, and configuration.
"""

WEATHER_VIBES_DESCRIPTOR = {
    "metadata": {
        "ref": {
            "name": "org.example.weathervibes",
            "version": "0.1.0",
            "url": "https://github.com/agntcy/agentic-apps/weather_vibes"
        },
        "description": "An agent that provides weather information, item recommendations, and matching YouTube videos."
    },
    "specs": {
        "capabilities": {
            "threads": True,
            "interrupts": False,
            "callbacks": False,
            "streaming": True
        },
        "input": {
            "type": "object",
            "description": "Input for the Weather Vibes agent",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The location to get weather for (city name, zip code, etc.)"
                },
                "units": {
                    "type": "string",
                    "enum": ["metric", "imperial"],
                    "default": "metric",
                    "description": "Unit system for temperature and measurements"
                }
            },
            "required": ["location"]
        },
        "output": {
            "type": "object",
            "description": "Weather Vibes agent output",
            "properties": {
                "weather": {
                    "type": "object",
                    "description": "Current weather information",
                    "properties": {
                        "location": {"type": "string"},
                        "temperature": {"type": "number"},
                        "condition": {"type": "string"},
                        "humidity": {"type": "number"},
                        "wind_speed": {"type": "number"}
                    }
                },
                "recommendations": {
                    "type": "array",
                    "description": "Items recommended to bring based on the weather",
                    "items": {"type": "string"}
                },
                "video": {
                    "type": "object",
                    "description": "A YouTube video matching the weather vibe",
                    "properties": {
                        "title": {"type": "string"},
                        "url": {"type": "string"},
                        "thumbnail": {"type": "string"}
                    }
                }
            }
        },
        "config": {
            "type": "object",
            "description": "Configuration for the Weather Vibes agent",
            "properties": {
                "verbose": {
                    "type": "boolean",
                    "default": False,
                    "description": "Whether to include detailed weather information"
                },
                "max_recommendations": {
                    "type": "integer",
                    "default": 5,
                    "description": "Maximum number of recommendations to provide"
                },
                "video_mood": {
                    "type": "string",
                    "description": "Optional mood override for video selection"
                }
            }
        },
        "thread_state": {
            "type": "object",
            "description": "Thread state for the Weather Vibes agent",
            "properties": {
                "search_history": {
                    "type": "array",
                    "description": "History of previously searched locations",
                    "items": {"type": "string"}
                },
                "favorite_locations": {
                    "type": "array",
                    "description": "User's favorite locations",
                    "items": {"type": "string"}
                }
            }
        }
    }
} 


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/agent/weather_vibes_agent.py
================================================
"""
Weather Vibes Agent implementation using the Simple Agent Framework.
"""
import os
import json
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional
from jinja2 import Environment, FileSystemLoader

from agent_framework.agent import Agent
from agent_framework.state import AgentState
from openai import OpenAI
# Remove AgentLogger import since it's now abstract
# from agent_framework.utils.logging import AgentLogger

# Use absolute imports instead of relative imports
# Replace: from ..tools import WeatherTool, RecommendationsTool, YouTubeTool
try:
    # Try direct import first
    from weather_vibes.tools.weather_tool import WeatherTool
    from weather_vibes.tools.recommendations_tool import RecommendationsTool
    from weather_vibes.tools.youtube_tool import YouTubeTool
except ImportError:
    try:
        # Try with tutorials prefix
        from tutorials.weather_vibes_agent.weather_vibes.tools.weather_tool import WeatherTool
        from tutorials.weather_vibes_agent.weather_vibes.tools.recommendations_tool import RecommendationsTool
        from tutorials.weather_vibes_agent.weather_vibes.tools.youtube_tool import YouTubeTool
    except ImportError:
        # Final fallback - try relative import as a last resort
        try:
            from ..tools.weather_tool import WeatherTool
            from ..tools.recommendations_tool import RecommendationsTool
            from ..tools.youtube_tool import YouTubeTool
        except ImportError:
            # Directly import from the current directory structure
            import sys
            import os.path
            sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            from tools.weather_tool import WeatherTool
            from tools.recommendations_tool import RecommendationsTool
            from tools.youtube_tool import YouTubeTool

from .descriptor import WEATHER_VIBES_DESCRIPTOR

# Configure standard logging
logger = logging.getLogger("weather_vibes_agent")

# Add metadata class methods to tools to match the updated API
# These are manually added here since we can't modify the original tool classes
def create_tool_metadata(name, description, tags=None):
    @classmethod
    def metadata(cls):
        return {
            "name": name, 
            "description": description,
            "tags": tags or []
        }
    return metadata

# Add metadata method to the tool classes if they don't have it
if not hasattr(WeatherTool, 'metadata'):
    WeatherTool.metadata = create_tool_metadata(
        "get_weather", 
        "Get the current weather conditions for a location",
        ["weather", "utility"]
    )

if not hasattr(RecommendationsTool, 'metadata'):
    RecommendationsTool.metadata = create_tool_metadata(
        "get_recommendations", 
        "Get recommendations for items to bring based on weather conditions",
        ["weather", "recommendations"]
    )

if not hasattr(YouTubeTool, 'metadata'):
    YouTubeTool.metadata = create_tool_metadata(
        "find_weather_video", 
        "Find a YouTube video that matches the weather vibe",
        ["youtube", "entertainment"]
    )

class WeatherVibesAgent(Agent):
    """
    Agent that provides weather information, recommendations, and matching videos.
    Implements the Agent Connect Protocol (ACP) for standardized communication.
    """
    
    def __init__(self, agent_id: str = "weather_vibes"):
        super().__init__(agent_id=agent_id)
        
        # Initialize state - the API has changed, so we use direct assignment now
        # Changed from self.state.set() to direct attribute assignment
        self.state = AgentState()
        
        # Default state initialization using direct attributes
        # Instead of self.state.set("search_history", []), use:
        if not hasattr(self.state, "search_history"):
            self.state.search_history = []
        if not hasattr(self.state, "favorite_locations"):
            self.state.favorite_locations = []
        
        # Set up template environment
        template_dir = Path(__file__).parent.parent / "templates"
        self.template_env = Environment(
            loader=FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Set up OpenAI client instead of OpenAIChat
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        
        # Instead of AgentLogger, use standard Python logging
        self.agent_id = agent_id
        logger.info(f"Initialized WeatherVibesAgent with ID: {self.agent_id}")
        
        # Register tools
        self._register_tools()
        
        # Store descriptor
        self.descriptor = WEATHER_VIBES_DESCRIPTOR
        
    def _register_tools(self) -> None:
        """Register agent-specific tools"""
        # First, inspect what type of object tool_registry is
        logger.info(f"Tool registry type: {type(self.tool_registry)}")
        
        # Let's try multiple different approaches
        try:
            # Create tool instances
            weather_tool = WeatherTool()
            recommendations_tool = RecommendationsTool()
            youtube_tool = YouTubeTool()
            
            # Try to figure out what the registry is and how to use it
            if hasattr(self.tool_registry, 'register'):
                # Approach 1: Check if register is a method that takes tool instances
                try:
                    logger.info("Trying direct tool registration with single argument")
                    # Try calling with a single argument
                    self.tool_registry.register(weather_tool)
                    self.tool_registry.register(recommendations_tool)
                    self.tool_registry.register(youtube_tool)
                    logger.info("Direct tool registration successful")
                    return
                except Exception as e:
                    logger.warning(f"Direct tool registration failed: {e}")
                
                # Approach 2: Try with keyword arguments
                try:
                    logger.info("Trying registration with keyword arguments")
                    self.tool_registry.register(tool=weather_tool)
                    self.tool_registry.register(tool=recommendations_tool)
                    self.tool_registry.register(tool=youtube_tool)
                    logger.info("Keyword tool registration successful")
                    return
                except Exception as e:
                    logger.warning(f"Keyword tool registration failed: {e}")
                    
                # Approach 3: Check if it's a dictionary-like registration
                try:
                    logger.info("Trying dictionary-style registration")
                    self.tool_registry.register({"get_weather": weather_tool})
                    self.tool_registry.register({"get_recommendations": recommendations_tool})
                    self.tool_registry.register({"find_weather_video": youtube_tool})
                    logger.info("Dictionary-style registration successful")
                    return
                except Exception as e:
                    logger.warning(f"Dictionary-style registration failed: {e}")

                # Approach 4: Check if the register method is actually a property to set
                try:
                    logger.info("Trying to treat register as a property")
                    # Try setting tools directly into the registry
                    setattr(self.tool_registry, "get_weather", weather_tool)
                    setattr(self.tool_registry, "get_recommendations", recommendations_tool)  
                    setattr(self.tool_registry, "find_weather_video", youtube_tool)
                    logger.info("Direct property setting successful")
                    return
                except Exception as e:
                    logger.warning(f"Property setting failed: {e}")
                    
            # Approach 5: Check if the tool_registry is a dictionary itself
            if hasattr(self.tool_registry, '__setitem__'):
                try:
                    logger.info("Treating tool_registry as a dictionary")
                    self.tool_registry["get_weather"] = weather_tool
                    self.tool_registry["get_recommendations"] = recommendations_tool
                    self.tool_registry["find_weather_video"] = youtube_tool
                    logger.info("Dictionary assignment successful")
                    return
                except Exception as e:
                    logger.warning(f"Dictionary assignment failed: {e}")
                    
            # Approach 6: Desperate attempt - try monkey patching the tool registry
            try:
                logger.info("Attempting to monkey patch the tool registry")
                # Create a simple in-memory tool lookup
                tool_lookup = {
                    "get_weather": weather_tool,
                    "get_recommendations": recommendations_tool,
                    "find_weather_video": youtube_tool
                }
                
                # Override the get_tool method
                def get_tool_override(name):
                    return tool_lookup.get(name)
                
                # Try to replace the method
                self.tool_registry.get_tool = get_tool_override
                logger.info("Monkey patching successful")
                return
            except Exception as e:
                logger.error(f"All tool registration approaches failed: {e}")
                raise ValueError(f"Unable to register tools. Tool registry type: {type(self.tool_registry)}")
        
        except Exception as e:
            logger.error(f"Failed to register tools: {e}")
            raise
    
    async def _generate_system_prompt(self) -> str:
        """Generate the system prompt using the template"""
        template = self.template_env.get_template("system.j2")
        return template.render(
            search_history=getattr(self.state, "search_history", []),
            favorite_locations=getattr(self.state, "favorite_locations", [])
        )
    
    async def _format_result(self, result: Any) -> Dict[str, Any]:
        """
        Format the result from processing.
        
        This is an abstract method required by the Agent base class.
        It formats the raw result into a standard structure.
        
        Args:
            result: The raw result from processing
            
        Returns:
            A formatted result dictionary
        """
        if isinstance(result, dict):
            return result
        elif hasattr(result, 'model_dump'):
            # Handle pydantic models
            return result.model_dump()
        elif hasattr(result, '__dict__'):
            # Handle objects with __dict__
            return result.__dict__
        else:
            # Default case
            return {"result": str(result)}
    
    async def get_acp_descriptor(self) -> Dict[str, Any]:
        """
        Return the ACP descriptor for this agent.
        This implements the ACP agent discovery capability.
        """
        return self.descriptor
        
    async def process_acp_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process an ACP request and generate a response.
        This implements the ACP run execution capability.
        
        Args:
            request: The ACP request payload
            
        Returns:
            An ACP response payload
        """
        # Replace AgentLogger methods with standard logging
        logger.info(f"Processing ACP request: {json.dumps(request)[:100]}...")
        
        try:
            # Extract relevant information from the request
            input_data = request.get("input", {})
            config = request.get("config", {})
            metadata = request.get("metadata", {})
            
            # Parse input and config
            location = input_data.get("location")
            units = input_data.get("units", "metric")
            verbose = config.get("verbose", False)
            max_recommendations = config.get("max_recommendations", 5)
            video_mood = config.get("video_mood")
            
            # Validate input
            if not location:
                logger.error("Invalid input: 'location' field is required")
                return {
                    "error": 400,
                    "message": "Invalid input: 'location' field is required"
                }
            
            # Update search history
            if not hasattr(self.state, "search_history"):
                self.state.search_history = []
                
            if location not in self.state.search_history:
                self.state.search_history.append(location)
                # Keep only last 5 items
                if len(self.state.search_history) > 5:
                    self.state.search_history = self.state.search_history[-5:]
            
            # Step 1: Get weather information
            logger.info(f"Getting weather for location: {location}")
            weather_tool = self.tool_registry.get_tool("get_weather")
            weather_result = await weather_tool.execute(location=location, units=units)
            
            if "error" in weather_result:
                logger.error(f"Weather API error: {weather_result['message']}")
                return {
                    "error": 500,
                    "message": f"Weather API error: {weather_result['message']}"
                }
            
            # Step 2: Get recommendations
            logger.info(f"Getting recommendations based on weather")
            recommendations_tool = self.tool_registry.get_tool("get_recommendations")
            recommendations = await recommendations_tool.execute(
                weather=weather_result,
                max_items=max_recommendations
            )
            
            # Step 3: Get matching YouTube video
            logger.info(f"Finding YouTube video matching weather condition: {weather_result['condition']}")
            youtube_tool = self.tool_registry.get_tool("find_weather_video")
            video_result = await youtube_tool.execute(
                weather_condition=weather_result["condition"],
                mood_override=video_mood
            )
            
            # Prepare the response
            result = {
                "weather": weather_result,
                "recommendations": recommendations,
                "video": video_result
            }
            
            # If not verbose, filter out some weather details
            if not verbose and "weather" in result:
                result["weather"] = {
                    "location": weather_result["location"],
                    "temperature": weather_result["temperature"],
                    "condition": weather_result["condition"],
                    "humidity": weather_result["humidity"],
                    "wind_speed": weather_result["wind_speed"]
                }
            
            # Format response according to ACP standards
            response = {
                "output": result
            }
            
            # Add the original agent_id to the response
            if "agent_id" in request:
                response["agent_id"] = request["agent_id"]
                
            # Add metadata if present in the request
            if metadata:
                response["metadata"] = metadata
                
            logger.info(f"Successfully processed request for location: {location}")
            return response
            
        except Exception as e:
            logger.error(f"Error processing request: {str(e)}")
            return {
                "error": 500,
                "message": f"Error processing request: {str(e)}"
            }


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/templates/system.j2
================================================
You are the Weather Vibes assistant, an agent that helps users get weather information, item recommendations, and matching music.

Your capabilities:
1. Get current weather for any location
2. Recommend items to bring based on weather conditions
3. Find YouTube videos that match the weather "vibe"

Search history:
{% if search_history %}
Recent locations:
{% for location in search_history %}
- {{ location }}
{% endfor %}
{% else %}
No recent searches.
{% endif %}

{% if favorite_locations %}
Favorite locations:
{% for location in favorite_locations %}
- {{ location }}
{% endfor %}
{% endif %}

When providing recommendations, consider:
- Temperature (cold, cool, warm, hot)
- Precipitation (rain, snow, etc.)
- Wind conditions
- Time of day

Be friendly, helpful, and practical in your recommendations.


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/tools/__init__.py
================================================
from .weather_tool import WeatherTool
from .recommendations_tool import RecommendationsTool
from .youtube_tool import YouTubeTool

__all__ = ["WeatherTool", "RecommendationsTool", "YouTubeTool"]


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/tools/recommendation_tool.py
================================================
"""
Tool for generating item recommendations based on weather conditions.
"""
from typing import Dict, Any, List
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool

class RecommendationsInput(BaseModel):
    """Input schema for recommendations tool"""
    weather: Dict[str, Any]
    max_items: int = 5

class RecommendationsTool(BaseTool):
    """Tool for generating weather-based recommendations"""
    name = "get_recommendations"
    description = "Get recommendations for items to bring based on weather conditions"
    tags = ["weather", "recommendations"]
    input_schema = RecommendationsInput.model_json_schema()
    
    async def execute(self, weather: Dict[str, Any], max_items: int = 5) -> List[str]:
        """
        Execute the tool to get recommendations.
        
        Args:
            weather: Weather information dictionary
            max_items: Maximum number of recommendations to provide
            
        Returns:
            List of recommended items
        """
        recommendations = []
        
        # Basic recommendation logic based on weather conditions
        condition = weather.get("condition", "").lower()
        temp = weather.get("temperature", 0)
        description = weather.get("description", "").lower()
        
        # Rain-related recommendations
        if any(x in condition.lower() or x in description.lower() for x in ["rain", "drizzle", "shower"]):
            recommendations.extend(["☔", "🧥" ])
        
        # Sun-related recommendations
        if any(x in condition.lower() or x in description.lower() for x in ["clear", "sun"]):
            recommendations.extend(["🕶️", "🧴", "🧢"])
        
        # Temperature-based recommendations
        if temp < 5:  # Cold
            recommendations.extend(["🎿", "🧤", "🧣", "🥶"])
        elif temp < 15:  # Cool
            recommendations.extend(["👖", "🧦", "🌫️"])
        elif temp < 25:  # Warm
            recommendations.extend(["👕", "🩳", "☀️"])
        else:  # Hot
            recommendations.extend(["🥵", "👙", "🌴", "🩴"])
        
        # Wind-related recommendations
        if weather.get("wind_speed", 0) > 20:
            recommendations.extend(["🌬️", "🪁"])
        
        # Return unique recommendations, limited to max_items
        unique_recommendations = list(set(recommendations))
        return unique_recommendations[:max_items]


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/tools/weather_tool.py
================================================
"""
Weather tool for fetching current weather conditions using OpenWeatherMap API.
"""
import os
from typing import Dict, Any, Optional
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool
import requests

class WeatherInput(BaseModel):
    """Input schema for the weather tool"""
    location: str
    units: str = "metric"

class WeatherTool(BaseTool):
    """Tool for fetching weather information"""
    name = "get_weather"
    description = "Get the current weather conditions for a location"
    tags = ["weather", "utility"]
    input_schema = WeatherInput.model_json_schema()
    
    def __init__(self):
        self.api_key = os.getenv("OPENWEATHERMAP_API_KEY")
        if not self.api_key:
            raise ValueError("OpenWeatherMap API key not found in environment")
        self.base_url = "http://api.openweathermap.org/data/2.5/weather"
    
    async def execute(self, location: str, units: str = "metric") -> Dict[str, Any]:
        """
        Execute the tool to get current weather.
        
        Args:
            location: The location to get weather for (city name, zip code, etc.)
            units: Unit system for temperature (metric or imperial)
            
        Returns:
            Dictionary containing weather information
        """
        params = {
            "q": location,
            "units": units,
            "appid": self.api_key
        }
        
        try:
            response = requests.get(self.base_url, params=params)
            response.raise_for_status()
            data = response.json()
            
            # Extract relevant weather information
            weather_info = {
                "location": data["name"],
                "temperature": data["main"]["temp"],
                "condition": data["weather"][0]["main"],
                "description": data["weather"][0]["description"],
                "humidity": data["main"]["humidity"],
                "wind_speed": data["wind"]["speed"],
                "icon": data["weather"][0]["icon"],
                "feels_like": data["main"]["feels_like"]
            }
            
            return weather_info
        except Exception as e:
            return {
                "error": str(e),
                "message": f"Failed to get weather for location: {location}"
            }


================================================
FILE: weather_vibes_agp/tutorials/02-weather-vibes-agent/weather_vibes/tools/youtube_tool.py
================================================
"""
Tool for finding YouTube videos that match the weather vibe.
"""
import os
from typing import Dict, Any, Optional
from pydantic import BaseModel
from agent_framework.tools.base import BaseTool
from googleapiclient.discovery import build

class YouTubeInput(BaseModel):
    """Input schema for YouTube tool"""
    weather_condition: str
    mood_override: Optional[str] = None

class YouTubeTool(BaseTool):
    """Tool for finding YouTube videos based on weather conditions"""
    name = "find_weather_video"
    description = "Find a YouTube video that matches the weather vibe"
    tags = ["youtube", "entertainment"]
    input_schema = YouTubeInput.model_json_schema()
    
    def __init__(self):
        self.api_key = os.getenv("YOUTUBE_API_KEY")
        if not self.api_key:
            raise ValueError("YouTube API key not found in environment")
        self.youtube = build('youtube', 'v3', developerKey=self.api_key)
    
    async def execute(self, weather_condition: str, mood_override: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute the tool to find a weather-matching YouTube video.
        
        Args:
            weather_condition: Current weather condition
            mood_override: Optional mood to override search query
            
        Returns:
            Dictionary containing video information
        """
        try:
            # Generate search query based on weather condition and optional mood
            if mood_override:
                query = f"{weather_condition} {mood_override} music"
            else:
                # Map weather conditions to vibes
                vibe_mapping = {
                    "clear": "sunny day vibes music",
                    "sun": "sunny afternoon music",
                    "clouds": "cloudy day chill music",
                    "rain": "rainy day lofi music",
                    "drizzle": "light rain ambience",
                    "thunderstorm": "thunderstorm cozy music",
                    "snow": "snowy day peaceful music",
                    "mist": "foggy morning ambient music",
                    "fog": "foggy atmosphere music"
                }
                
                # Find the closest matching vibe
                for condition_key, vibe_phrase in vibe_mapping.items():
                    if condition_key in weather_condition.lower():
                        query = vibe_phrase
                        break
                else:
                    query = f"{weather_condition} music vibes"
            
            # Execute search
            search_response = self.youtube.search().list(
                q=query,
                part="snippet",
                maxResults=1,
                type="video"
            ).execute()
            
            # Extract video information
            if search_response.get("items"):
                video = search_response["items"][0]
                video_id = video["id"]["videoId"]
                
                return {
                    "title": video["snippet"]["title"],
                    "url": f"https://www.youtube.com/watch?v={video_id}",
                    "thumbnail": video["snippet"]["thumbnails"]["high"]["url"],
                    "channel": video["snippet"]["channelTitle"],
                    "query": query
                }
            else:
                return {"error": "No videos found", "query": query}
        
        except Exception as e:
            return {
                "error": str(e),
                "message": "Failed to find a matching YouTube video"
            }

